<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pacman</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      position: relative;
      color: #fff;
      font-family: sans-serif;
    }
    #score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      z-index: 2;
    }
    canvas {
      background: #000;
      image-rendering: pixelated;
      border: 5px solid white;
      z-index: 1;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 64px;
      text-align: center;
      flex-direction: column;
      z-index: 3;
      visibility: hidden;
    }
    #overlay button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 24px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>
  <div id="overlay">
    <div id="game-over-text"></div>
    <button id="restart-btn">Restart</button>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const gameOverText = document.getElementById('game-over-text');
    const restartBtn = document.getElementById('restart-btn');

    const map = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1],
      [1,2,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,2,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1],
      [1,0,0,0,0,1,0,0,0,0,0,2,2,2,2,0,0,0,0,1,0,0,0,0,0,0,0,1],
      [1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1],
      [1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1],
      [1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1],
      [1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
      [1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],
      [1,0,2,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,2,0,2,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    const scale = 2 / 3;
    const tileSize = 80 * scale;
    const rows = map.length;
    const cols = map[0].length;
    const canvasWidth = cols * tileSize;
    const canvasHeight = rows * tileSize;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    const speed = 10;
    let frameCount = 0;
    let gameOver = false;

    let totalDots = 0;
    map.forEach(row => row.forEach(cell => { if (cell === 0) totalDots++; }));

    let score = 0;
    const pacman = { x: 1, y: 1, dir: { x: 1, y: 0 }, nextDir: { x: 0, y: 0 } };
    const ghosts = [
      { x: 13, y: 7, dir: { x: 1, y: 0 }, color: 'red', emoji: 'ðŸ‘»' },
      { x: 14, y: 7, dir: { x: -1, y: 0 }, color: 'pink', emoji: 'ðŸ‘»' }
    ];

    document.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowUp': pacman.nextDir = { x: 0, y: -1 }; break;
        case 'ArrowDown': pacman.nextDir = { x: 0, y: 1 }; break;
        case 'ArrowLeft': pacman.nextDir = { x: -1, y: 0 }; break;
        case 'ArrowRight': pacman.nextDir = { x: 1, y: 0 }; break;
      }
    });

    function canMove(x, y) {
      return map[y] && map[y][x] !== 1;
    }

    function update() {
      const prevPac = { x: pacman.x, y: pacman.y };
      const prevGhosts = ghosts.map(g => ({ x: g.x, y: g.y }));

      const nx = pacman.x + pacman.nextDir.x;
      const ny = pacman.y + pacman.nextDir.y;
      if (canMove(nx, ny)) pacman.dir = pacman.nextDir;
      const px = pacman.x + pacman.dir.x;
      const py = pacman.y + pacman.dir.y;
      if (canMove(px, py)) { pacman.x = px; pacman.y = py; }

      if (map[pacman.y][pacman.x] === 0) {
        map[pacman.y][pacman.x] = 2;
        score++;
        scoreBoard.textContent = 'Score: ' + score;
        if (score === totalDots) {
          gameOver = true;
          gameOverText.innerHTML = `Victory!<br>Score: ${score}`;
          overlay.style.visibility = 'visible';
        }
      }

      ghosts.forEach((g, i) => {
        const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        const ok = canMove(g.x + g.dir.x, g.y + g.dir.y);
        if (!ok || Math.random() < 0.1) {
          const opts = dirs.filter(d => canMove(g.x + d.x, g.y + d.y));
          if (opts.length) g.dir = opts[Math.floor(Math.random() * opts.length)];
        }
        g.x += g.dir.x;
        g.y += g.dir.y;
        const prevG = prevGhosts[i];
        const collision =
          (g.x === pacman.x && g.y === pacman.y) ||
          (prevPac.x === g.x && prevPac.y === g.y && prevG.x === pacman.x && prevG.y === pacman.y);
        if (collision && !gameOver) {
          gameOver = true;
          gameOverText.innerHTML = `Game Over<br>Score: ${score}`;
          overlay.style.visibility = 'visible';
        }
      });
    }

    restartBtn.addEventListener('click', () => location.reload());

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const v = map[y][x];
          if (v === 1) ctx.fillStyle = 'blue';
          else if (v === 0) ctx.fillStyle = 'white';
          if (v === 1) ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          if (v === 0) {
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize/2, y * tileSize + tileSize/2, tileSize/8, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      }
      
      // Draw Pacman
      const cx = pacman.x * tileSize + tileSize/2;
      const cy = pacman.y * tileSize + tileSize/2;
      const dir = pacman.dir;
      let angle = Math.atan2(dir.y, dir.x);
      if (dir.x === 0 && dir.y === 0) angle = 0;
      const m = 0.25 * Math.PI;
      ctx.fillStyle = 'yellow';
      ctx.beginPath();
      ctx.arc(cx, cy, tileSize/2 - tileSize*0.05, angle + m, angle - m, false);
      ctx.lineTo(cx, cy);
      ctx.fill();

      // Draw Ghosts as emoji
      ghosts.forEach(g => {
        ctx.font = `${tileSize * 0.8}px 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = g.color;
        ctx.fillText(g.emoji, g.x * tileSize + tileSize/2, g.y * tileSize + tileSize/2);
      });
    }

    function loop() {
      frameCount++;
      if (frameCount % speed === 0 && !gameOver) update();
      draw();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>